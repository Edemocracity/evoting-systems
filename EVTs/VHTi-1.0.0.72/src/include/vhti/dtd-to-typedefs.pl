#!/usr/bin/perl
# 
# This material is subject to the VoteHere Source Code Evaluation
# License Agreement ("Agreement").  Possession and/or use of this
# material indicates your acceptance of this Agreement in its entirety.
# Copies of the Agreement may be found at www.votehere.net.
# 
# Copyright 2004 VoteHere, Inc.  All Rights Reserved
# 
# You may not download this Software if you are located in any country
# (or are a national of a country) subject to a general U.S. or
# U.N. embargo or are deemed to be a terrorist country (i.e., Cuba,
# Iran, Iraq, Libya, North Korea, Sudan and Syria) by the United States
# (each a "Prohibited Country") or are otherwise denied export
# privileges from the United States or Canada ("Denied Person").
# Further, you may not transfer or re-export the Software to any such
# country or Denied Person without a license or authorization from the
# U.S. government.  By downloading the Software, you represent and
# warrant that you are not a Denied Person, are not located in or a
# national of a Prohibited Country, and will not export or re-export to
# any Prohibited Country or Denied Party.

use warnings;
use strict;
use Data::Dumper;
use FindBin;

my $dtd = qq($FindBin::Bin/../dtds/vhti.dtd);

# We'll embed this name inside a comment in the .h files.  We
# translate backslashes to forward slashes so that TeX doesn't barf on
# it.
my $this_script_posix_name = qx(cygpath -u "$0");

my @element_names;
my @attribute_names;

# Parse out the names, warn about duplicates.
{
  open (DTD, "<", $dtd)
    or die "Can't open $dtd for reading: $!; stopped";

  my %element_names;
  my %attribute_names;

  my $last_element_declaration_seen;

  while (<DTD>) {

    # skip lines that are commented out.
    next if (m(^// ));

  SWITCH: {

      m(<!ELEMENT\s+(\w+)\s) && do  {
        $last_element_declaration_seen = $1;
        $element_names{$last_element_declaration_seen}++;
        warn "Element $last_element_declaration_seen appears more than once in $dtd" if (2 == $element_names{$last_element_declaration_seen});

        last SWITCH;
      };

      m(^(\w+)\s+CDATA\s+#(REQUIRED|IMPLIED)) && do {
        die "Saw an attribute ($1) without first having seen an element declaration"
          unless $last_element_declaration_seen;

        $attribute_names{$1}++;

        last SWITCH;
      };
    }

  }
  close (DTD)
    or warn "Can't close filehandle: $!";

  @element_names   = sort
    #{ lc ($a) cmp lc ($b) }
      (keys %element_names);
  @attribute_names = sort (keys %attribute_names);
}

sub HumptySplit {
  # Break words when an uppercase follows lowercase ...
  # fooBar -> foo Bar
  (my $words = $_[0]) =~ s(([a-z])([A-Z])){$1 $2}g;

  # FOOBar -> FOO Bar
  $words =~ s(([A-Z]+)([A-Z][a-z])){$1 $2}g;

  # foo_bar -> foo bar
  $words =~ s(_){ }g;
  [split m(\s), $words];
}

my $macros_file = "${FindBin::Bin}/auto-macros.h";

if (-r($macros_file)
    &&
    -M($dtd) >= -M($macros_file)) {
  print "$macros_file is no older than $dtd; not regenerating\n";
} else {
  open (MACROS, ">", $macros_file)
    or die "Can't open $macros_file for writing: $!; stopped";

  print MACROS qq(/* Automatically generated by $this_script_posix_name from $dtd; do not edit */\n);
  print MACROS qq(
/*
 * We use these macros instead of string constants to detect typos at
 * compile time instead of a runtime.
 */
);

  print MACROS qq(#ifndef AUTO_MACROS_H\n#define AUTO_MACROS_H\n\n);

  my %all_names;
  foreach (@element_names, @attribute_names) {
    $all_names{$_}++;
  }
  foreach (sort
           # { lc ($a) cmp lc ($b) }
           (keys (%all_names))) {
    my @words = @{HumptySplit ($_)};
    my $macro_name = join ('_', map { (my $up = $_) =~ tr/a-z/A-Z/; $up } @words);

  SWITCH: {
      # we can't define certain macros, because they would conflict
      # with typedefs, enums, and what-have-you in other headers :(
      if ("SIZE" eq $macro_name) {
        print MACROS qq(#define PERMUTATION_SIZE "Size"\n); last SWITCH;
      }

      if ("ENCODING" eq $macro_name) {
        print MACROS qq(#define ATT_ENCODING "Encoding"\n); last SWITCH;
      }
      print MACROS qq(#define $macro_name "$_"\n);

    }
  }
  print MACROS qq (\n#endif\n);
  close (MACROS)
    or warn "Can't close filehandle: $!";
}

my $typedefs_file = "${FindBin::Bin}/auto-typedefs.h";

if (-r ($typedefs_file)
    &&
    -M($dtd) >= -M($typedefs_file)) {
  print "$typedefs_file is no older than $dtd; not regenerating\n"
} else {
  open (TYPEDEFS, ">", $typedefs_file)
    or die "Can't open $typedefs_file for writing: $!; stopped";

  print TYPEDEFS qq(/* Automatically generated by $this_script_posix_name from $dtd; do not edit */\n);

  print TYPEDEFS qq(#ifndef AUTO_TYPEDEFS_H\n#define AUTO_TYPEDEFS_H\n\n);

  foreach (@element_names) {
    print TYPEDEFS qq(typedef const char * $_;\n);
  }

  # Something (automatic generation of TeX docs, I think) downstream
  # breaks if this line isn't present.
  print TYPEDEFS qq(\ntypedef const char * ConstCharStar;\n);

  print TYPEDEFS qq(\n#endif\n);
  close (TYPEDEFS)
    or warn "Can't close filehandle: $!";
}
