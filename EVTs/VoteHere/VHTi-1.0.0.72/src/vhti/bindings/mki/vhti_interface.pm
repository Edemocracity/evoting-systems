# 
# This material is subject to the VoteHere Source Code Evaluation
# License Agreement ("Agreement").  Possession and/or use of this
# material indicates your acceptance of this Agreement in its entirety.
# Copies of the Agreement may be found at www.votehere.net.
# 
# Copyright 2004 VoteHere, Inc.  All Rights Reserved
# 
# You may not download this Software if you are located in any country
# (or are a national of a country) subject to a general U.S. or
# U.N. embargo or are deemed to be a terrorist country (i.e., Cuba,
# Iran, Iraq, Libya, North Korea, Sudan and Syria) by the United States
# (each a "Prohibited Country") or are otherwise denied export
# privileges from the United States or Canada ("Denied Person").
# Further, you may not transfer or re-export the Software to any such
# country or Denied Person without a license or authorization from the
# U.S. government.  By downloading the Software, you represent and
# warrant that you are not a Denied Person, are not located in or a
# national of a Prohibited Country, and will not export or re-export to
# any Prohibited Country or Denied Party.
# Copyright 2003 VoteHere Inc. All Rights Reserved.

package mki::VHTI_Interface;

use Data::Dumper;
use Carp;
use File::Slurp;
#use UUID; Damn cygwin...
use File::Spec;
use File::Path;
use FindBin qw($RealBin);
use Cwd;

our $generator_loaded_flag = 1;

*include_file       = *add_include_file;
*include_all_path   = *add_include_path;
*include_glob       = sub { my $self = shift; $self->{include_glob} = shift; };
*type_file          = *add_type_file;
*function_file      = *read_functions;
*version            = sub { my $self = shift; $self->{version} = shift; @{$self->{ar_version}} = split /\./,$self->{version}; };
*root_path          = sub { 
  my $self = shift; 
  $self->{root_path} = shift; 
  mkpath($self->{root_path},0); 
};
*config_file        = *process_config_file;
*script_file        = *add_script;
*copyright_file   = sub { my $self = shift; $self->{copyright_notice} = read_file(shift); chomp($self->{copyright_notice}); };
*license_file   = sub { my $self = shift; $self->{license_text} = read_file(shift); };
*break = sub { exit; };
*stop  = sub { print "<CONTINUE>"; <STDIN>; };
*say   = sub { print "$_[1]\n"; };

our $c_identifier_regex = "(?:[a-z_A-Z][a-z_A-Z_0-9]*)";
our ($vol,$dir,$basename) = File::Spec->splitpath($0);

sub new {
  my $class = shift;
  my $self = { 
    include_data   => { },
    types          => [ ],
    types_exp      => undef,
    verbose 	   => undef,
    include_glob   => "*.h",
    interface_loaded => 1,
    scripts        => [],
    warn_text    => qq(
------------------------------------------------------------------------------

 This file was generated automatically by $basename
 from the contents of the public VHTI headers. 
 
 Do not edit this file, edit those headers instead!

	ANY CHANGES MADE HERE WILL BE LOST!
------------------------------------------------------------------------------
    ),
    copyright_notice => read_file("$RealBin/mki/copyright.txt"),
    license_text   => read_file("$RealBin/mki/license.txt"),
    root_path => getcwd(),
    scripts   => [],
    real_bin => $RealBin,
    include_files => [],
  };
  chomp($self->{copyright_notice});
  bless $self,$class;
}

sub add_script {
  my $self = shift;
  my $script = "$RealBin/".shift;
  push @{$self->{scripts}},$script;
}

sub process_config_file {
  my $self = shift;
  my $file = shift;
  if (! -e $file) {
    if (-e "$RealBin/mki/$file") { $file = "$RealBin/mki/$file"; }
    elsif (-e "$RealBin/$file") { $file = "$RealBin/$file"; }
    else { croak "Unable to load config file $file, $!"; }
  }
  my $data = read_file($file);
  $data =~ s/\r//mg; 
  while ($data =~ /\s*((.*?)\s*=\s*(.*?)\s*\n)/mg) { 
    my ($l,$k,$v) = ( $1, $2, $3);
    next if ($l =~ /^\s*#/);
    $self->{verbose} && print "Config Directive: $2 => $3;\n";
    if ($k =~ /^\$(.+)/) { $self->{$1} = $v; next; }
    $v =~ s/\$(.+?)\b/$self->{$1}/sg;

    &$k($self,$v);
  }
}

sub add_include_file {
  croak "add_include_path(path,[glob])" if (@_ < 1); 
  my $self = shift;
  my $file = shift;
  $self->{verbose} && print "Adding include $file\n";
  push @{$self->{include_files}},$file;
  $self->{include_data}->{$file} = read_file($file) 
      || croak "Unable to open include file $file, $!";
}

sub add_include_path  {
  croak "add_include_path(path,[glob])" if (@_ < 1); 
  my $self = shift;
  my $path = $RealBin."/".shift;
  my $glob = shift || $self->{include_glob};
  croak "Cannot find directory $path, $!" if (! -e $path);
  my $count = 0;
  foreach $file (glob("$path\/$glob")) {
    $self->add_include_file($file);
    $count++;
  }
  $self->{verbose} && print "Include path $path : $count files included\n";
}

sub add_type_file {
  my $self = shift;
  my $file = shift || die "Required '$types_file_name' file not found";
  croak "Unable to load type definition file $file, $!" if (! -e $RealBin."/".$file);
  map {
    push @{$self->{types}},/^typedef\s+const\s+char\s*\*\s*(.*?);/;
  } read_file($RealBin."/".$file); 
}

sub generate_functions {
  my $self = shift;

  $self->{types_regex} = join '|', sort @{$self->{types}};
  map {
    while ($self->{include_data}->{$_} =~ /(EXPORT_SYMBOL\s+int\s+(VHTI_\w+)\s*\(([^)]*)\))/mg) {
      $raw_functions{$2} = $2; 
      &mk_arg_list($self, $2, $3, $_);
      $self->{verbose} && printf " Export %-50s [%d]\n",$2,0;
    }
  } sort keys %{ $self->{include_data} };

# Including these for now, since some interfaces may require these
  # Get rid of the free function.  No-one will ever use it.  Same for dup.
  #delete $self->{functions}->{'VHTI_free'};
  #delete $self->{functions}->{'VHTI_dup'};
  mk_file_structs($self);
}

sub mk_file_structs {
  my $self = shift;
  my %thash;
  map {
    my $func = $self->{functions}->{$_};
    my $fname = $_;

    if (! exists $thash{$func->{'FILE'}}) {
      push @{$self->{function_files}},$func->{'FILE'};
      $thash{$func->{'FILE'}} = 1;
    }
    push @{$self->{functions_by_file}->{$func->{'FILE'}}},$fname; 
  } keys %{$self->{functions}};
  $self->{'debug'} && print Dumper($self->{function_files});
  $self->{'debug'} && print Dumper($self->{functions_by_file});
}

sub mk_arg_list {
   my $self = shift;
   my $fname = shift;
   my $param_list = shift;
   my $filename = shift;

   my $pos = 0;
   $fname =~ /^VHTI_/;
   my $this_function = $self->{'functions'}->{$fname} = { 
      FILE => $filename, 
      NAME => $fname,
      SHORT => $',
      ARGS => [], 
      IN => [], 
      OUT => [], 
   };

   PARAM: for my $param (split /\s*,\s*/m, $param_list) {
      my $new_arg = 0;
      $param =~ s/\/\/.*\n//g;
      $param =~ s/^\s+//g;
      SWITCH: {
	 $param =~ /void/ && do {
	    # void, no 'real' parameters.
	    last PARAM;
	 };
	 $param =~ /int\s+($c_identifier_regex)/ && do { 
	    # IN int parameter.
	    $new_arg = { 
	       NAME => "p_$1", 
	       TNAME => "t_$1", 
	       TYPE => 'INTEGER',
	       CTYPE => 'int',
	       RTYPE => 'int',
	       DIR => 'IN',
	    };
	    last SWITCH; 
	 };
	 $param =~ /char\s*\*\s*\*\s*($c_identifier_regex)/ && do { 
	    # OUT string paramteter.
	    $new_arg = { 
	       NAME => "p_$1", 
	       TNAME => "t_$1", 
	       TYPE => 'STRING', 
	       CTYPE => 'char *',
	       RTYPE => 'char *',
	       DIR => 'OUT',
	    };
            carp "non-const char argument found in $fname ($filename)" unless $` =~ /const\s+/;
	    last SWITCH; 
	 };
	 $param =~ /int\s*\*\s*($c_identifier_regex)/ && do { 
	    # OUT int parameter.
	    $new_arg = { 
	       NAME => "p_$1", 
	       TNAME => "t_$1", 
	       TYPE => 'INTEGER',
	       CTYPE => 'int',
	       RTYPE => 'int',
	       DIR => 'OUT',
	    };
	    last SWITCH; 
	 };
	 $param =~ /char\s*\*\s*($c_identifier_regex)/ && do { 
	    # IN string parameter.
	    $new_arg = { 
	       NAME => "p_$1", 
	       TNAME => "t_$1", 
	       TYPE => 'STRING',
	       CTYPE => 'char *',
	       RTYPE => 'char *',
	       DIR => 'IN',
	    };
            carp "non-const char argument found in $fname ($filename)" unless $` =~ /const\s+/;
	    last SWITCH; 
	 };
	 
	 $param =~ /($$self{types_regex})\s*\*\s*($c_identifier_regex)/ && do { 
	    # OUT xml (string) parmeter.
	    $new_arg = { 
	       NAME => "p_$2", 
	       TNAME => "t_$2", 
	       TYPE => 'STRING', 
  	       CTYPE => 'char *',
	       RTYPE => $1,
	       DIR => 'OUT',
	    };
	    last SWITCH; 
	 };
	 $param =~ /($$self{types_regex})\s+($c_identifier_regex)/ && do { 
	    # IN xml (string) paramter.
	    $new_arg = { 
	       NAME => "p_$2", 
	       TNAME => "t_$2", 
	       TYPE => 'STRING',
	       CTYPE => 'char *',
	       RTYPE => $1,
	       DIR => 'IN',
	    };
	    last SWITCH; 
	 };
	 
	 croak "Unrecognized parameter type in function $fname: $param";
      }
      push @{$this_function->{ARGS}}, $new_arg;
      push @{$this_function->{$new_arg->{DIR}}}, $new_arg;
      $self->{'debug'} && print "\t\t PARAMS: $fname -> $new_arg->{NAME}\n"; 
   }
}

sub dump_functions {
# Dump out the function structure to STDOUT or IO handle
  my $self = shift;
  $Data::Dumper::Purity = 1;
  my $f = shift || *STDOUT{IO};
  if (defined $self->{root_path}) { $f = $self->{root_path}."/".$f; }
  else { $f = $RealBin."/".$f; }
  print "Dumping functions to handle: $f\n";
  write_file($f,Dumper($self->{functions},$self->{include_files}));
  $Data::Dumper::Purity = 0;
  return 1;
}

sub flush_functions {
  my $self = shift;
  $self->{functions} = {};
  $self->{function_files}=[];
  $self->{functions_by_file} = {};
}

sub read_functions {
  my $self = shift;
  my $file = shift || croak "read_functions() requires file parameter."; 
  if (! -e $file) {
    if (-e $RealBin."/".$file) { 
      warn "Using found functions file in $RealBin\n";
      $file = $RealBin."/".$file;
    }
  }
  my $eval = read_file($file);
  $eval =~ s/\$VAR1/\$self->{functions}/gm;
  $eval =~ s/\$VAR2/\$self->{include_files}/gm;
  eval $eval;
  map { 
    $self->{verbose} && printf " Imported %-50s from %-20s\n",$_,$self->{functions}->{$_}->{FILE}; 
  } keys %{$self->{functions}};
  map { 
    $self->{verbose} && printf " Include %-50s from %-20s\n",$_; 
  } @{$self->{include_files}};
  mk_file_structs($self);
}

sub do_script {
  $| = 1;
  my $self = shift;
  my $script = shift || $self->{script_file} || croak "No script specified.";
  if (! -e $script) { 
    if (-e $RealBin."/".$script) { $script = $RealBin."/".$script; }
    elsif (-e $RealBin."/mki/".$script) { $script = $RealBin."/mki/".$script; }
    else {
      croak "The script file $script does no exist" if (1 != -e $script); 
    }
  }
  $self->{verbose} && print "Processing script $script\n";
  # Some quick variable assignments (should use refs here)
  # so script writers don't have to use the OO interface to self.
  local %functions         = %{$self->{functions}};
  local @function_files    = @{$self->{function_files}};
  local %functions_by_file = %{$self->{functions_by_file}};
  local @include_files    = @{$self->{include_files}};

  local $standard_header   = join ("\n",$self->{'copyright_notice'},"",$self->{'license_text'},$self->{'warn_text'});
  local $version          = $self->{'version'};
  local @version          = @{$self->{ar_version}};
  local $copyright_notice = $self->{copyright_notice};
  local $license_notice   = $self->{license_notice};
  local $warn_text        = $self->{header_text};
  local $root_path        = $self->{root_path};

  # We also dupe $self in case they do want to call into here with the
  # object, but would rather use a better name for descriptive purpose.
  local $generator = $self;
  
  my $eval = read_file($script);
  croak "Unable to read script file $script\n" if (1 != defined $eval);
  print "Script error: $@\n" if (! defined eval $eval);
}

#----------------------------------------------------------------------------#
# End of object methods. These are functions that are available to scripts,
# which are not required to know about the current object.  
#
# All new functions in this section must use local variables defined in
# do_script().  Add one if you need.
#----------------------------------------------------------------------------#
sub out_script {
  my $filename = shift;
  my $r_template = shift;
  my $r_template = do_template($r_template);
  if (defined $root_path) { $filename = $root_path."/".$filename; }
  print "Writing template to file $filename\n";
  my ($v,$d,$f) = File::Spec->splitpath($filename);
  mkpath($d,0);
  write_file("$filename",$r_template);
  return $filename;
}

sub do_template {
  my $r_template = shift;
  $r_template =~ s/{=\s*(.*?)\s*=}/eval $1/egs;
  $r_template =~ s/\r//g;
  return $r_template;
}

sub get_names { map { '$' . $_->{NAME} } @{$_[0]}; }

sub get_base_filenames {
  my @filelist = @_; 
  if (@filelist < 1) { @filelist = keys %functions_by_file; }
  map {
     /(?:.*?\/)*(.*)$/;
     $1;
  } sort @filelist;
}

sub make_version {
  my $div = shift;
  my $sep = shift || ".";
  my @pri_version = @version[0..$div-1];
  my @sub_version = @version[$div..@version];
  return join($sep,@pri_version,join("",@sub_version));
}

sub no_vhti_free {
  delete $functions{'VHTI_free'};
}

sub no_vhti_dup {
  delete $functions{'VHTI_dup'};
}

sub function($) { return $functions{shift @_}; }
sub functions { return (keys %functions); }
sub include_files() { return (@function_files); }
sub file_functions($) { return (values %{$functions_by_file{shift @_}}); }
sub function_arg($) { return $functions{shift @_}->{ARGS}->[shift @_]; }
sub function_args($) { return @{$functions{shift @_}->{ARGS}}; }
sub function_in($) { return $functions{shift @_}->{IN}->[shift @_]; }
sub function_ins($) { return @{$functions{shift @_}->{IN}}; }
sub function_out($) { return $functions{shift @_}->{OUT}->[shift @_]; }
sub function_outs($) { return @{$functions{shift @_}->{OUT}}; }
sub function_num_outs($) { return $#{$functions{shift @_}->{OUT}}+1; }
sub function_name($) { return $functions->{shift @_}->{NAME}; }
sub function_file($) { return $functions->{shift @_}->{FILE}; }
sub function_short($) { return $functions{shift @_}->{SHORT}; }

sub new_uuid { # Damn cygwin...
  my $uuid = `uuidgen`;
  if (! defined $uuid) { croak "You do not appear to have uuidgen!"; }
  chomp($uuid); chomp($uuid);
  return "\U$uuid"; 
}

sub new_uuid_w32 { # Damn cygwin...
  #my ($uuid,$string);
  #UUID::generate($uuid); 
  #UUID::unparse($uuid,$string);
  #return $string;
}

__END__


=head1 NAME

VHTI_Interface - Helper functions and framework for generating wrappers for VoteHere's voting API.

=head1 SYNOPSIS

  use VHTI_Interface;

  Likely what you actually want to do is use the included mkinterface.pl script.

=head1 DESCRIPTION

  <NEED DOCS>

=head2 EXPORT

  None by default.

=head1 COPYRIGHT AND LICENSE

  Copyright 2003 by VoteHere, Inc.

=cut
1;
